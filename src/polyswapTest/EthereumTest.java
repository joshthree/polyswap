/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package polyswapTest;

import java.io.IOException;
import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.List;

import org.web3j.crypto.Credentials;
import org.web3j.crypto.ECDSASignature;
import org.web3j.crypto.ECKeyPair;
import org.web3j.crypto.Hash;
import org.web3j.crypto.Keys;
import org.web3j.crypto.RawTransaction;
import org.web3j.crypto.Sign;
import org.web3j.crypto.TransactionEncoder;
import org.web3j.crypto.Sign.SignatureData;
import org.web3j.protocol.Web3j;
import org.web3j.protocol.core.DefaultBlockParameter;
import org.web3j.protocol.core.DefaultBlockParameterName;
import org.web3j.protocol.core.methods.request.Transaction;
import org.web3j.protocol.core.methods.response.EthCoinbase;
import org.web3j.protocol.core.methods.response.EthGetBalance;
import org.web3j.protocol.core.methods.response.EthGetTransactionCount;
import org.web3j.protocol.core.methods.response.EthSendTransaction;
import org.web3j.protocol.core.methods.response.Web3ClientVersion;
import org.web3j.protocol.http.HttpService;
import org.web3j.rlp.RlpEncoder;
import org.web3j.rlp.RlpList;
import org.web3j.rlp.RlpType;
import org.web3j.utils.Convert;
import org.web3j.utils.Convert.Unit;
import org.web3j.utils.Numeric;

import polyswap.Ethereum;
import sssig.SSSECDSA;

public class EthereumTest {
	
	public static void main(String[] args) throws InterruptedException {
		Ethereum eth = new Ethereum(12312);
		String recv = eth.generateAddress();
		//System.out.println("Receiving address: " + recv );
		eth.loadCoins("0x94f3854627826c37f5ba1f227ef42751e1e973b1","1");
		System.out.println("Receiving address balance: " + eth.getBalance("0x94f3854627826c37f5ba1f227ef42751e1e973b1"));
		Web3j cl = eth.getClient();
		
		boolean condition = false;
		if (condition) {
			SSSECDSA k = new SSSECDSA();
			Object[] keyPair = k.keygen(new SecureRandom());
			BigInteger secKey = (BigInteger) keyPair[0];
			System.out.println("secret key" + secKey);
			Credentials cred = Credentials.create(ECKeyPair.create(secKey));
			String from = cred.getAddress();
			//Thread.sleep(60000);
			eth.loadCoins(from,"1");
			System.out.println("Sending address:" + from);
			System.out.println("Sending address balance: before: " + eth.getBalance(from));
			SSSECDSA k1 = new SSSECDSA();
			Object[] keyPair1 = k1.keygen(new SecureRandom());
			BigInteger secKey1 = (BigInteger) keyPair1[0];
			
			Credentials cred1 = Credentials.create(ECKeyPair.create(secKey1));
			String to = cred1.getAddress();
			System.out.println("receiving address: " + to);
			System.out.println("receiving address balance: before: " + eth.getBalance(to));
			BigInteger value = Convert.toWei("1", Unit.ETHER).toBigInteger();
			try {
				byte[] signedTx = EthereumTest.createDepositTransaction(cl, k, secKey, from, to, value);
				EthSendTransaction ethSendTransaction = cl.ethSendRawTransaction(Numeric.toHexString(signedTx)).send();
				System.out.println("sending trancation");
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			Thread.sleep(1000);
			System.out.println("receiving address balance: after: " + eth.getBalance(to));
			System.out.println("Sending address balance: after: " + eth.getBalance(from));
		} else {
			
			BigInteger secKey = new BigInteger("105350008383112045721866847906147769089021363911297721931878380371882383604286");
			Credentials cred = Credentials.create(ECKeyPair.create(secKey));
			String from = cred.getAddress();
			//Thread.sleep(60000);
			eth.loadCoins(from,"1");
			System.out.println("Sending address:" + from);
			System.out.println("Sending address balance: before: " + eth.getBalance(from));
			SSSECDSA k1 = new SSSECDSA();
			Object[] keyPair1 = k1.keygen(new SecureRandom());
			BigInteger secKey1 = (BigInteger) keyPair1[0];
			//System.out.println("secret key" + secKey1);
			Credentials cred1 = Credentials.create(ECKeyPair.create(secKey1));
			String to = cred1.getAddress();
			System.out.println("receiving address: " + to);
			System.out.println("receiving address balance: before: " + eth.getBalance(to));
			BigInteger value = Convert.toWei("1", Unit.ETHER).toBigInteger();
			try {
				byte[] signedTx = EthereumTest.createDepositTransaction(cl, k1, secKey, from, to, value);
				EthSendTransaction ethSendTransaction = cl.ethSendRawTransaction(Numeric.toHexString(signedTx)).send();
				System.out.println("sending trancation");
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			Thread.sleep(1000);
			System.out.println("receiving address balance: after: " + eth.getBalance(to));
			System.out.println("Sending address balance: after: " + eth.getBalance(from));
		}
		
		
		
		
		
	}
	
	
    public static void overallTest(String [] args) throws IOException {
    	Web3j web3 = Web3j.build(new HttpService());
    	Web3ClientVersion web3ClientVersion = web3.web3ClientVersion().send();
    	//System.out.println("this is a string");
    	System.out.println(web3ClientVersion.getWeb3ClientVersion());
    	
    	//private and public key pair generated from SSSECDSA
    	BigInteger privateKey = new BigInteger("96421006805663924994292209396143790219852843251166445851505405159687615937562");
    	ECKeyPair kp = ECKeyPair.create(privateKey);
    	System.out.println();
    	Credentials cred = Credentials.create(kp);
    	System.out.println(cred.getAddress());
    	BigInteger publicKey 
    	= new BigInteger("7900210639682514783297544394323515341858651155119351586976736795453546683010552939604907576292625183259315074702859862741569035514161011585263939154290372");
    	String publicAddress = Numeric.prependHexPrefix(Keys.getAddress(publicKey));
    	System.out.println(publicAddress);
    	
    	EthCoinbase cb = web3.ethCoinbase().send();
    	System.out.println("Coin base address " + cb.getAddress());
    	
    	EthGetBalance bal = web3.ethGetBalance(cb.getAddress(), DefaultBlockParameter.valueOf("latest")).send();
    	System.out.println(bal.getBalance());
    	
    	System.out.println("Balance in coinbase:" + Convert.fromWei(bal.getBalance().toString(), Unit.ETHER) + " Ether");
    	
    	//Get the latest nonce
    	EthGetTransactionCount ethGetTransactionCount = web3.ethGetTransactionCount(cb.getAddress(), DefaultBlockParameterName.LATEST).send();
    	BigInteger nonce = ethGetTransactionCount.getTransactionCount();
    	
    	// value to transfer
    	BigInteger value = Convert.toWei("1", Unit.ETHER).toBigInteger();
    	
    	//Gas Parameters
    	BigInteger gasLimit = BigInteger.valueOf(21000);
    	BigInteger gasPrice = Convert.toWei("1", Unit.GWEI).toBigInteger();
    	
    	
    	//Prepare the rawTransaction
    	//private key generated from ECDSASSIG
    	BigInteger sk2 = new BigInteger("26552144654319586874152160033374991152228906068474034635292476513307235429233");
    	ECKeyPair kp2 = ECKeyPair.create(sk2);
    	Credentials cred2 = Credentials.create(kp2);
    	String pk2 = cred2.getAddress();
    	System.out.println("Receiving address " + pk2 );
    	
    	RawTransaction rawTransaction1 = RawTransaction.createEtherTransaction(nonce, gasPrice, gasLimit, pk2, value);
    	
    	byte[] signedTx = TransactionEncoder.signMessage(rawTransaction1, cred);
    	
    	//send transaction
    	EthSendTransaction ethSendTransaction = web3.ethSendRawTransaction(Numeric.toHexString(signedTx)).send();
    	
    	String transactionHash = ethSendTransaction.getTransactionHash();
    	System.out.println("Transaction hash " + transactionHash);
    	//Preparing the 
    	
    	EthGetBalance bal2 = web3.ethGetBalance(pk2, DefaultBlockParameter.valueOf("latest")).send();
    	System.out.println("Balance in receiving address " + bal2.getBalance());
    	
    	//Transaction coin = new Transaction(web3.ethCoinbase(), new BigInteger("1"), new BigInteger("2"), new BigInteger("3"), publicAddress, , data)
    	
    	//web3.ethSendTransaction(web3.ethCoinbase()))
    }
    
    public static byte[] createDepositTransaction(Web3j web3, SSSECDSA k , BigInteger sk, String from, String to, BigInteger value) throws IOException {
    	
    	EthGetTransactionCount ethGetTransactionCount = web3.ethGetTransactionCount(from, DefaultBlockParameterName.LATEST).send();
    	BigInteger nonce = ethGetTransactionCount.getTransactionCount();
    	
    	BigInteger gasLimit = BigInteger.valueOf(21000);
    	BigInteger gasPrice = Convert.toWei("1", Unit.GWEI).toBigInteger();
    	
    	RawTransaction dTx = RawTransaction.createEtherTransaction(nonce, gasPrice, gasLimit, to, value);
    	
    	// chainId to reflect proper chain where the transaction needs to be accepted
//    	Ethereum mainnet 1
//    	Morden (obsolete), Expanse 		2
//    	Ropsten    	3
//
//    	Rinkeby    	4
//
//    	Rootstock mainnet    	30
//
//    	Rootstock testnet    	31
//
//    	Kovan    	42
//
//    	Ethereum Classic mainnet    	61
//
//    	Ethereum Classic testnet    	62
//
//    	Geth private testnets    	1337
//    	or can be null;
    	if(true) {
    		byte[] encodedTransaction = TransactionEncoder.encode(dTx);
        	ECKeyPair keyPair = ECKeyPair.create(sk);
        	 BigInteger publicKey = keyPair.getPublicKey();
             
             byte[]   messageHash = Hash.sha3(encodedTransaction);
             
             BigInteger m = k.calculateBigIntegerforMessage(messageHash);
             BigInteger[] sigParts = k.sign(m, sk);
     		 ECDSASignature sig = new ECDSASignature(sigParts[0], sigParts[1]).toCanonicalised();
             // Now we have to work backwards to figure out the recId needed to recover the signature.
             int recId = -1;
             for (int i = 0; i < 4; i++) {
                 BigInteger j = Sign.recoverFromSignature(i, sig, messageHash);
                 if (j != null && j.equals(publicKey)) {
                     recId = i;
                     break;
                 }
             }
             if (recId == -1) {
                 throw new RuntimeException(
                         "Could not construct a recoverable key. Are your credentials valid?");
             }

             int headerByte = recId + 27;

             // 1 header + 32 bytes for R + 32 bytes for S
             byte[] v = new byte[] {(byte) headerByte};
             byte[] r = Numeric.toBytesPadded(sig.r, 32);
             byte[] s = Numeric.toBytesPadded(sig.s, 32);

        	Sign.SignatureData signatureData = new SignatureData(v, r, s);
        	List<RlpType> values = TransactionEncoder.asRlpValues(dTx, signatureData);
            RlpList rlpList = new RlpList(values);
            return RlpEncoder.encode(rlpList);
    	}
    	long chainId = 0;
    	byte[] encodedTransaction = TransactionEncoder.encode(dTx, chainId);
    	ECKeyPair keyPair = ECKeyPair.create(sk);
    	 BigInteger publicKey = keyPair.getPublicKey();
         
         byte[]   messageHash = Hash.sha3(encodedTransaction);
         
         BigInteger m = k.calculateBigIntegerforMessage(messageHash);
         BigInteger[] sigParts = k.sign(m, sk);
 		 ECDSASignature sig = new ECDSASignature(sigParts[0], sigParts[1]).toCanonicalised();
         // Now we have to work backwards to figure out the recId needed to recover the signature.
         int recId = -1;
         for (int i = 0; i < 4; i++) {
             BigInteger j = Sign.recoverFromSignature(i, sig, messageHash);
             if (j != null && j.equals(publicKey)) {
                 recId = i;
                 break;
             }
         }
         if (recId == -1) {
             throw new RuntimeException(
                     "Could not construct a recoverable key. Are your credentials valid?");
         }

         int headerByte = recId + 27;

         // 1 header + 32 bytes for R + 32 bytes for S
         byte[] v = new byte[] {(byte) headerByte};
         byte[] r = Numeric.toBytesPadded(sig.r, 32);
         byte[] s = Numeric.toBytesPadded(sig.s, 32);

    	Sign.SignatureData signatureData = new SignatureData(v, r, s);
    	Sign.SignatureData eip155SignatureData = TransactionEncoder.createEip155SignatureData(signatureData, chainId);
        List<RlpType> values = TransactionEncoder.asRlpValues(dTx, eip155SignatureData);
        RlpList rlpList = new RlpList(values);
        return RlpEncoder.encode(rlpList);
        
        
    	
    }
}
