/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package polyswap;

import java.io.IOException;
import java.io.Serializable;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import org.bitcoinj.core.Address;
import org.bitcoinj.core.ECKey;
import org.bitcoinj.script.Script.ScriptType;
import org.web3j.abi.FunctionEncoder;
import org.web3j.abi.datatypes.Function;
import org.web3j.abi.datatypes.Type;
import org.web3j.abi.datatypes.generated.Uint8;
import org.web3j.crypto.Credentials;
import org.web3j.crypto.ECDSASignature;
import org.web3j.crypto.ECKeyPair;
import org.web3j.crypto.Hash;
import org.web3j.crypto.Keys;
import org.web3j.crypto.RawTransaction;
import org.web3j.crypto.Sign;
import org.web3j.crypto.TransactionEncoder;
import org.web3j.crypto.Sign.SignatureData;
import org.web3j.protocol.Web3j;
import org.web3j.protocol.core.DefaultBlockParameter;
import org.web3j.protocol.core.DefaultBlockParameterName;
import org.web3j.protocol.core.methods.request.Transaction;
import org.web3j.protocol.core.methods.response.EthCoinbase;
import org.web3j.protocol.core.methods.response.EthGetBalance;
import org.web3j.protocol.core.methods.response.EthGetTransactionCount;
import org.web3j.protocol.core.methods.response.EthSendTransaction;
import org.web3j.protocol.core.methods.response.Web3ClientVersion;
import org.web3j.protocol.http.HttpService;
import org.web3j.rlp.RlpEncoder;
import org.web3j.rlp.RlpList;
import org.web3j.rlp.RlpType;
import org.web3j.tx.gas.DefaultGasProvider;
import org.web3j.utils.Convert;
import org.web3j.utils.Convert.Unit;

import sssig.SSSECDSA;

import org.web3j.utils.Numeric;

import polyswap.contracts.TimeLock;

public class Ethereum implements Serializable{

	/**
	 * 
	 */
	private static final long serialVersionUID = 9116588293395602849L;

	public static final String REGTEST_NET = ""; // this url need not be set as the Web3j client defaults to regression testing

	public static final String RINKEBY_NET = "http://localhost:8545/";

	RawTransaction dTx, rTx, cTx;

	public String CONTRACT_ADDRESS = "0x03B03bE182E59d10466cC029ab992f1ee4f4474c";


	/**
	 * chainId reflects the chain where the transaction is targeted:
	 * Ethereum mainnet 1
	 * Ropsten 3
	 * Rinkeby 4
	 * Rootstock mainnet 30
	 * Rootstock testnet 31
	 * Kovan 42
	 * Ethereum Classic mainnet 61
	 * Ethereum Classic testnet 62
	 * Geth private testnet 1337
	 * or also can be null for web3j api
	 *
	 */
	private int chainId = 0;

	private Web3j client;

	public Ethereum(int a) {
		switch(a) {
		case 1:	
			client = Web3j.build(new HttpService(RINKEBY_NET)); // Rinkeby testnet mode: port: 30303
			break;
		case 2:
			client = Web3j.build(new HttpService()); // reg test mode
			break;
		case 3:
			client = Web3j.build(new HttpService("https://rinkeby.infura.io/v3/3ceded5567d4415fb89585dce48526cb"));
			break;
		default:
			client = Web3j.build(new HttpService()); // defaults to reg test mode
		}
	}

	/**
	 * @return Web3j client
	 * This method returns the Web3j client that was created. Useful for running specific method calls to the network.
	 */
	public Web3j getClient() {
		return this.client;
	}

	/**
	 * This method imports the keys to the accounts in blockchain which can be spent by this user.
	 * Hard coded for now for Rinkeby testnet address.
	 * 75733117964815864349485508608744919890163072985157085067813108114561150366215 for address 0xb21558312f99b8e6d1399718cc9da9b35b1739ab
	 */
	public void loadCoins() {
		BigInteger skLoadAddress = new BigInteger("105350008383112045721866847906147769089021363911297721931878380371882383604286");
		String loadAddress =  "0x94f3854627826c37f5ba1f227ef42751e1e973b1";
		Credentials cred = Credentials.create(ECKeyPair.create(skLoadAddress));
		System.out.println("Balance: " + getBalance(cred.getAddress()));

	}

	public String[] loadNewAddress() {
		ECKey key = new ECKey();
		Credentials cred = Credentials.create(ECKeyPair.create(key.getPrivKey()));
		String sk = key.getPrivKey().toString();
		String address = cred.getAddress();
		loadCoins(address, "0.006");
		return new String[] {sk, address};
	}

	public Credentials loadNewCredentials() {
		ECKey key = new ECKey();
		Credentials cred = Credentials.create(ECKeyPair.create(key.getPrivKey()));
		String sk = key.getPrivKey().toString();
		String address = cred.getAddress();
		loadCoins(address, "0.001");
		return cred;
	}


	public BigInteger utilConvertToBigInteger(String val) {
		return new BigInteger(val);
	}

	public BigInteger getPrivateKeyforBaseAddress() {
		return new BigInteger("105350008383112045721866847906147769089021363911297721931878380371882383604286");
	}

	public String getBaseAddress() {
		return "0x94f3854627826c37f5ba1f227ef42751e1e973b1";
	}

	public String getNewAddress() {
		ECKey key = new ECKey();
		Credentials cred = Credentials.create(ECKeyPair.create(key.getPrivKey()));
		System.out.println("sk: " + key.getPrivKey() +  " for " + cred.getAddress());
		return cred.getAddress();
	}

	@Deprecated
	public String generateAddress(){
		BigInteger privateKey = new BigInteger("96421006805663924994292209396143790219852843251166445851505405159687615937563");
		ECKeyPair kp = ECKeyPair.create(privateKey);
		Credentials cred = Credentials.create(kp);
		return cred.getAddress();
	}

	public BigDecimal getBalance(String a){
		EthGetBalance bal = null;
		try {
			bal = client.ethGetBalance(a, DefaultBlockParameter.valueOf("latest")).send();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return Convert.fromWei(bal.getBalance().toString(), Unit.ETHER);
	}
	
	
	/**
	 * @param address address to send coins from coinbase to
	 * @param val value in Ether
	 * Only for Ethereum regtest mode:
	 * sudo docker run -p 8545:8545 -p 8546:8546 --mount type=bind,source=/home/keer4n/docker/besu/testnode,target=/var/lib/besu hyperledger/besu:latest --miner-enabled --miner-coinbase 6f0c98b2a31aeef1645c858ebf395475ecbb35fb --rpc-http-enabled --rpc-ws-enabled --network=dev --data-path=/var/lib/besu
	 * This method loads coins to a given address for the given value.
	 */
	public void loadCoins(String address, String val){
		//BigInteger privateKey = new BigInteger("96421006805663924994292209396143790219852843251166445851505405159687615937562");
		BigInteger privateKey = getPrivateKeyforBaseAddress();
		ECKeyPair kp = ECKeyPair.create(privateKey);
		Credentials cred = Credentials.create(kp);

		System.out.println("Current balance of coinbase is: " + getBalance(cred.getAddress()));

		EthGetTransactionCount ethGetTransactionCount;
		try {
			ethGetTransactionCount = client.ethGetTransactionCount(cred.getAddress(), DefaultBlockParameterName.LATEST).send();
			BigInteger nonce = ethGetTransactionCount.getTransactionCount();
			BigInteger value = Convert.toWei(val, Unit.ETHER).toBigInteger();

			//Gas Parameters
			BigInteger gasLimit = BigInteger.valueOf(210000);
			BigInteger gasPrice = Convert.toWei("1", Unit.GWEI).toBigInteger();

			//Prepare the rawTransaction

			RawTransaction rawTransaction = RawTransaction.createEtherTransaction(nonce, gasPrice, gasLimit, address, value);

			byte[] signedTx = TransactionEncoder.signMessage(rawTransaction, cred);

			//send transaction
			EthSendTransaction ethSendTransaction = client.ethSendRawTransaction(Numeric.toHexString(signedTx)).send();

			String transactionHash = ethSendTransaction.getTransactionHash();

		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}   	
	}
	

	/**
	 * @param address address to send coins from coinbase to
	 * @param val value in Ether
	 * Only for Ethereum regtest mode:
	 * sudo docker run -p 8545:8545 -p 8546:8546 --mount type=bind,source=/home/keer4n/docker/besu/testnode,target=/var/lib/besu hyperledger/besu:latest --miner-enabled --miner-coinbase 6f0c98b2a31aeef1645c858ebf395475ecbb35fb --rpc-http-enabled --rpc-ws-enabled --network=dev --data-path=/var/lib/besu
	 * This method loads coins to a given address for the given value.
	 */
	public String loadContract(Credentials cred, String address, String val){
		//BigInteger privateKey = new BigInteger("96421006805663924994292209396143790219852843251166445851505405159687615937562");
		
		System.out.println("Current balance of sending account is: " + getBalance(cred.getAddress()));
		String transactionHash = null;
		EthGetTransactionCount ethGetTransactionCount;
		try {
			ethGetTransactionCount = client.ethGetTransactionCount(cred.getAddress(), DefaultBlockParameterName.LATEST).send();
			BigInteger nonce = ethGetTransactionCount.getTransactionCount();
			BigInteger value = Convert.toWei(val, Unit.ETHER).toBigInteger();

			//Gas Parameters
			BigInteger gasLimit = BigInteger.valueOf(210000);
			BigInteger gasPrice = Convert.toWei("1", Unit.GWEI).toBigInteger();

			//Prepare the rawTransaction

			RawTransaction rawTransaction = RawTransaction.createEtherTransaction(nonce, gasPrice, gasLimit, address, value);

			byte[] signedTx = TransactionEncoder.signMessage(rawTransaction, cred);

			//send transaction
			EthSendTransaction ethSendTransaction = client.ethSendRawTransaction(Numeric.toHexString(signedTx)).send();

			transactionHash = ethSendTransaction.getTransactionHash();

		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}   	
		return transactionHash;
	}
	
	public String deploy(String owner, BigInteger timePeriod) throws Exception {
		//credentials0xd82ef6feafef489bb020da298f09d444093acec9

		BigInteger privateKey = new BigInteger("89179811265080136650681266953673138167329384320295414412418920727415236104720");
		Credentials cred = Credentials.create(ECKeyPair.create(privateKey));
		polyswap.contracts.TimeLock t = polyswap.contracts.TimeLock.deploy(client, cred, new DefaultGasProvider(),owner, timePeriod).send();
		return t.getContractAddress();
	}
	
	//value is in Wei
	
	  public BigInteger createDepositTransaction(String from, String to, BigInteger
	  value) throws Exception {
	 // String contractAddress = deploy(to, time);
	  
	  EthGetTransactionCount ethGetTransactionCount =
	  client.ethGetTransactionCount(from, DefaultBlockParameterName.LATEST).send();
	  BigInteger nonce = ethGetTransactionCount.getTransactionCount(); 
	  //BigInteger nonce = new BigInteger();
	  
	  BigInteger gasLimit = BigInteger.valueOf(21000); BigInteger gasPrice =
	  Convert.toWei("1", Unit.GWEI).toBigInteger();
	  
	  dTx = RawTransaction.createEtherTransaction(nonce, gasPrice, gasLimit, to,
	  value);
	  
	  
	  
	  byte[] encodedTransaction = TransactionEncoder.encode(dTx);
	  
	  
	  byte[] messageHash = Hash.sha3(encodedTransaction);
	  
	  return SSSECDSA.calculateBigIntegerforMessage(messageHash); 
	  }
	
	

	//value is in Wei
	
	  public BigInteger createDepositTransaction(String from, String to, BigInteger
	  value, BigInteger time) throws Exception {
	  CONTRACT_ADDRESS = deploy(to, time);
	  
	  EthGetTransactionCount ethGetTransactionCount =
	  client.ethGetTransactionCount(from, DefaultBlockParameterName.LATEST).send();
	  BigInteger nonce = ethGetTransactionCount.getTransactionCount(); 
	  //BigInteger nonce = new BigInteger();
	  
	  BigInteger gasLimit = BigInteger.valueOf(210000); 
	  BigInteger gasPrice =
	  Convert.toWei("1", Unit.GWEI).toBigInteger();
	  
	  dTx = RawTransaction.createEtherTransaction(nonce, gasPrice, gasLimit, CONTRACT_ADDRESS,
	  value);
	  
	  
	  
	  byte[] encodedTransaction = TransactionEncoder.encode(dTx);
	  
	  
	  byte[] messageHash = Hash.sha3(encodedTransaction);
	  
	  return SSSECDSA.calculateBigIntegerforMessage(messageHash); 
	  }
	 
	
//	public BigInteger createDepositTransaction(String from, String jointAccount, BigInteger value, BigInteger timePeriod) throws IOException {
//		Function function = new Function("deposit",
//				Arrays.asList(new Uint8(timePeriod), new org.web3j.abi.datatypes.Address(jointAccount)), Collections.emptyList());
//
//		//Encode function values in transaction data format
//		String txData = FunctionEncoder.encode(function);
//
//		EthGetTransactionCount ethGetTransactionCount = client.ethGetTransactionCount(from, DefaultBlockParameterName.LATEST).send();
//		BigInteger nonce = ethGetTransactionCount.getTransactionCount();
//
//		BigInteger gasLimit = BigInteger.valueOf(210000);
//		BigInteger gasPrice = Convert.toWei("1", Unit.GWEI).toBigInteger();
//
//		dTx = RawTransaction.createTransaction(nonce, gasPrice, gasLimit, CONTRACT_ADDRESS, value, txData);
//		//	RawTransaction.createEtherTransaction(nonce, gasPrice, gasLimit, to, value)
//		//SSSECDSA k = new SSSECDSA();
//		return SSSECDSA.calculateBigIntegerforMessage(Hash.sha3(TransactionEncoder.encode(dTx)));
//	}
	
	public BigInteger createRefundTransaction(String owner, String to) throws Exception {
		//Credentials cred = loadNewCredentials();
		//contract deploying address: 0x01cbe6303a0e4068f066c9210b8a8480c08541e6
		// Private key 2587274611756545707518412361145401515884164554969896614325210466388506039791
		Credentials cred = Credentials.create("2587274611756545707518412361145401515884164554969896614325210466388506039791");
		System.out.println("contract deploying address: "+ cred.getAddress() + "\n Private key" + cred.getEcKeyPair().getPrivateKey());
		//Thread.sleep(10000);
		//TimeLock t = TimeLock.deploy(client, cred, new DefaultGasProvider(), timePeriodInMinutes, owner).send();

		//timeLockContractAddress = t.getContractAddress();
	//	System.out.println("contract address: " + timeLockContractAddress);

		Function function = new Function("refund",
				Arrays.asList(new org.web3j.abi.datatypes.Address(to)), Collections.emptyList());

		//Encode function values in transaction data format
		String txData = FunctionEncoder.encode(function);

		EthGetTransactionCount ethGetTransactionCount = client.ethGetTransactionCount(owner, DefaultBlockParameterName.LATEST).send();
		BigInteger nonce = ethGetTransactionCount.getTransactionCount();

		BigInteger gasLimit = BigInteger.valueOf(210000);
		BigInteger gasPrice = Convert.toWei("1", Unit.GWEI).toBigInteger();

		rTx = RawTransaction.createTransaction(nonce, gasPrice, gasLimit, CONTRACT_ADDRESS, txData);

		//SSSECDSA k = new SSSECDSA();
		return SSSECDSA.calculateBigIntegerforMessage(Hash.sha3(TransactionEncoder.encode(rTx)));
	}
	
	public BigInteger createRefundTransaction(String owner, String to, String contractAddress) throws Exception {
		//Credentials cred = loadNewCredentials();
		//contract deploying address: 0x01cbe6303a0e4068f066c9210b8a8480c08541e6
		// Private key 2587274611756545707518412361145401515884164554969896614325210466388506039791
		Credentials cred = Credentials.create("2587274611756545707518412361145401515884164554969896614325210466388506039791");
		System.out.println("contract deploying address: "+ cred.getAddress() + "\n Private key" + cred.getEcKeyPair().getPrivateKey());
		//Thread.sleep(10000);
		//TimeLock t = TimeLock.deploy(client, cred, new DefaultGasProvider(), timePeriodInMinutes, owner).send();

		//timeLockContractAddress = t.getContractAddress();
	//	System.out.println("contract address: " + timeLockContractAddress);

		Function function = new Function("refund",
				Arrays.asList(new org.web3j.abi.datatypes.Address(to)), Collections.emptyList());

		//Encode function values in transaction data format
		String txData = FunctionEncoder.encode(function);

		EthGetTransactionCount ethGetTransactionCount = client.ethGetTransactionCount(owner, DefaultBlockParameterName.LATEST).send();
		BigInteger nonce = ethGetTransactionCount.getTransactionCount();

		BigInteger gasLimit = BigInteger.valueOf(210000);
		BigInteger gasPrice = Convert.toWei("1", Unit.GWEI).toBigInteger();

		rTx = RawTransaction.createTransaction(nonce, gasPrice, gasLimit, contractAddress, txData);

		//SSSECDSA k = new SSSECDSA();
		return SSSECDSA.calculateBigIntegerforMessage(Hash.sha3(TransactionEncoder.encode(rTx)));
	}


	public RawTransaction getRefundTransaction() {
		return rTx;
	}

	public BigInteger createClaimTransaction(String owner, String to) throws IOException {
		Function function = new Function("claim",
				Arrays.asList(new org.web3j.abi.datatypes.Address(to)), Collections.emptyList());

		//Encode function values in transaction data format
		String txData = FunctionEncoder.encode(function);

		EthGetTransactionCount ethGetTransactionCount = client.ethGetTransactionCount(owner, DefaultBlockParameterName.LATEST).send();
		BigInteger nonce = ethGetTransactionCount.getTransactionCount();

		BigInteger gasLimit = BigInteger.valueOf(210000);
		BigInteger gasPrice = Convert.toWei("1", Unit.GWEI).toBigInteger();

		cTx = RawTransaction.createTransaction(nonce, gasPrice, gasLimit, CONTRACT_ADDRESS, txData);

		//SSSECDSA k = new SSSECDSA();
		return SSSECDSA.calculateBigIntegerforMessage(Hash.sha3(TransactionEncoder.encode(cTx)));
	}
	
	public BigInteger createClaimTransaction(String owner, String to, String contractAddress) throws IOException {
		Function function = new Function("claim",
				Arrays.asList(new org.web3j.abi.datatypes.Address(to)), Collections.emptyList());

		//Encode function values in transaction data format
		String txData = FunctionEncoder.encode(function);

		EthGetTransactionCount ethGetTransactionCount = client.ethGetTransactionCount(owner, DefaultBlockParameterName.LATEST).send();
		BigInteger nonce = ethGetTransactionCount.getTransactionCount();

		BigInteger gasLimit = BigInteger.valueOf(210000);
		BigInteger gasPrice = Convert.toWei("1", Unit.GWEI).toBigInteger();

		cTx = RawTransaction.createTransaction(nonce, gasPrice, gasLimit, contractAddress, txData);

		//SSSECDSA k = new SSSECDSA();
		return SSSECDSA.calculateBigIntegerforMessage(Hash.sha3(TransactionEncoder.encode(cTx)));
	}

	public RawTransaction getClaimTransaction() {
		return cTx;
	}


	public BigInteger createTransaction(String from, String to, BigInteger value, String nonceValue) throws IOException {

		//EthGetTransactionCount ethGetTransactionCount = client.ethGetTransactionCount(from, DefaultBlockParameterName.LATEST).send();
		//BigInteger nonce = ethGetTransactionCount.getTransactionCount();
		BigInteger nonce = new BigInteger(nonceValue);
		BigInteger gasLimit = BigInteger.valueOf(21000);
		BigInteger gasPrice = Convert.toWei("1", Unit.GWEI).toBigInteger();

		dTx = RawTransaction.createEtherTransaction(nonce, gasPrice, gasLimit, to, value);

		byte[] encodedTransaction = TransactionEncoder.encode(dTx);


		byte[]   messageHash = Hash.sha3(encodedTransaction);

		return SSSECDSA.calculateBigIntegerforMessage(messageHash);
	}

	/**
	 * @return
	 */
	public RawTransaction getDepositTransaction() {
		return (dTx);
	}

	public byte[] signTransaction(RawTransaction dTx, BigInteger[] signatureComponents, BigInteger pubKey) {
		byte[]   messageHash = Hash.sha3(TransactionEncoder.encode(dTx));
		//byte[] messageHash = dTx;
		ECDSASignature sig = new ECDSASignature(signatureComponents[0], signatureComponents[1]).toCanonicalised();
		//Now we have to work backwards to figure out the recId needed to recover the signature.
		int recId = -1;
		for (int i = 0; i < 4; i++) {
			BigInteger j = Sign.recoverFromSignature(i, sig, messageHash);
			if (j != null && j.equals(pubKey)) {
				recId = i;
				break;
			}
		}
		if (recId == -1) {
			throw new RuntimeException(
					"Could not construct a recoverable key. Are your credentials valid?");
		}
		int headerByte = recId + 27;

		// 1 header + 32 bytes for R + 32 bytes for S
		byte[] v = new byte[] {(byte) headerByte};
		byte[] r = Numeric.toBytesPadded(sig.r, 32);
		byte[] s = Numeric.toBytesPadded(sig.s, 32);

		Sign.SignatureData signatureData = new SignatureData(v, r, s);
		List<RlpType> values = TransactionEncoder.asRlpValues(dTx, signatureData);
		RlpList rlpList = new RlpList(values);
		return RlpEncoder.encode(rlpList);
	}


}
